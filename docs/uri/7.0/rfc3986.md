---
layout: default
title: RFC3986 URI Object API
---

RFC3986 URI
=======

The `League\Uri\Uri` class implements:

- League's own [UriInterface](https://github.com/thephpleague/uri-interfaces/blob/master/src/Contracts/UriInterface.php) contracts
- PHP's [JsonSerializable](https://php.net/jsonserializable) interfaces.

The class handles all URI schemes and default to
[RFC3986](https://tools.ietf.org/html/rfc3986) rules if the scheme is not present and not
recognized as special.

## Instantiation

<p class="message-warning">The default constructor is private and can not be accessed to
instantiate a new object.</p>

The `League\Uri\Uri` class comes with the following named constructors to ease
instantiation.

<p class="message-info">All named constructors supports parameter widening. When a string
is expected, objects implementing the <code>__toString</code> method can be used.</p>

~~~php
<?php

public static function Uri::new(Stringable|string $uri = ''): self
public static function Uri::fromComponents(array $components): self
public static function Uri::fromBaseUri(Stringable|string $uri, Stringable|string|null $baseUri = null): self
public static function Uri::fromTemplate(Stringable|string $template, iterable $variables = []): self
public static function Uri::fromDataPath(Stringable|string $path, $context = null): self
public static function Uri::fromUnixPath(Stringable|string $uri = ''): self
public static function Uri::fromWindowsPath(Stringable|string $uri = ''): self
public static function Uri::fromServer(array $server): self
~~~

### Using a URI

~~~php
<?php

use League\Uri\Uri;
use Laminas\Diactoros\Uri as LaminasUri;

$uri = Uri::new('http://example.com/path/to?q=foo%20bar#section-42');

$laminasUri = new LaminasUri("http://www.example.com/path/to/the/sky");
$laminasUri->getQuery(); //return '';

$leagueUri = Uri::new($laminasUri);
$leagueUri->getQuery(); //return null;
~~~

<p class="message-info">If no input is provided an instance representing the empty string
is returned.</p>

### Using Uri components

~~~php
use League\Uri\Uri;
use League\Uri\UriString;

$uri = Uri::fromComponents(
	UriString::parse("http://uri.thephpleague/7.0/uri/api")
);
~~~

<p class="message-warning">If you supply your own hash to <code>fromComponents</code>,
you are responsible for providing well parsed components without their URI delimiters.</p>

### Using environment variables

~~~php
//don't forget to provide the $_SERVER array
$uri = Uri::fromServer($_SERVER);
~~~

<p class="message-warning">The method only relies on the server's safe parameters to
determine the current URI. If you are using the library behind a proxy the result may
differ from your expectation as no <code>$_SERVER['HTTP_X_*']</code> header is taken
into account for security reasons.</p>

### Using a base URI

Resolves a URI as a browser would for a relative URI.

~~~php
$uri = Uri::fromBaseUri(
	"./p#~toto",
	"http://www.example.com/path/to/the/sky/"
);

echo $uri; //displays "http://www.example.com/path/to/the/sky/p#~toto"
~~~

This method expect at most two variables. The URL to resolve and the base URL to use for
resolution. If not base URL is provided, the URL to resolve **must** be absolute. On the
other hand, if a base URL is provided it **must** be absolute. 

### Using a URI Template

Resolves a URI using the rules from RFC6570:

~~~php

$template = 'https://example.com/hotels/{hotel}/bookings/{booking}';
$variables = ['booking' => '42', 'hotel' => 'Rest & Relax'];

$uri = Uri::fromTemplate($template, $variables);

echo $uri->toString(); //displays "https://example.com/hotels/Rest%20%26%20Relax/bookings/42"
~~~

This method expect at most two variables. The URI template to resolve and the variables use
for resolution. You can get more in-depth understanding of
[URI Template](/7.0/uri-template) in its dedicated section of the documentation.


### Using the content of a file

Returns a new URI object with the `data` scheme and using the content of the file located
at the provided path. Because the function uses internally PHP's file streaming
capabilities an optional
[context resource](https://www.php.net/manual/en/stream.contexts.php) can be used to better
access the file content.

~~~php
$uri = Uri::fromDataPath('path/to/my/png/image.png');
echo $uri; //returns 'data:image/png;charset=binary;base64,...'
//where '...' represent the base64 representation of the file
~~~

### Using a Windows file path

Returns a new URI object using the `file` scheme for a Windows file path.

~~~php
$uri = Uri::fromWindowsPath('c:\windows\My Documents\my word.docx');
echo $uri; //returns 'file://localhost/c:My%20Documents/my%20word.docx'
~~~

### Using a Unix file path

Returns a new URI object using the `file` scheme for a Unix file path.

~~~php
$uri = Uri::fromUnixPath('/path/to/my/file.xml');
echo $uri; //returns 'file://localhost/path/to/my/file.xml'
~~~

Accessing URI properties
-------

The [RFC3986](https://tools.ietf.org/html/rfc3986) URI object exposes the following methods.

~~~php
public function Uri::__toString(): string
public function Uri::toString(): string
public function Uri::getScheme(): ?string
public function Uri::getUserInfo(): ?string
public function Uri::getHost(): ?string
public function Uri::getPort(): ?int
public function Uri::getAuthority(): ?string
public function Uri::getPath(): string
public function Uri::getQuery(): ?string
public function Uri::getFragment(): ?string
public function Uri::jsonSerialize(): string
~~~

<p class="message-info">Apart from the path component, which is always a string, all the
other URI components can be <code>null</code></p>

You can access the URI string, its individual parts and components using their respective
getter methods. This lead to the following result for a simple HTTP URI:

~~~php
$uri = Uri::new("http://foo:bar@www.example.com:81/how/are/you?foo=baz#title");
echo $uri->getScheme();    //displays "http"
echo $uri->getUserInfo();  //displays "foo:bar"
echo $uri->getHost();      //displays "www.example.com"
echo $uri->getPort();      //displays 81 as an integer
echo $uri->getAuthority(); //displays "foo:bar@www.example.com:81"
echo $uri->getPath();      //displays "/how/are/you"
echo $uri->getQuery();     //displays "foo=baz"
echo $uri->getFragment();  //displays "title"
echo $uri->toString();
//displays "http://foo:bar@www.example.com:81/how/are/you?foo=baz#title"
echo json_encode($uri);
//displays "http:\/\/foo:bar@www.example.com:81\/how\/are\/you?foo=baz#title"
~~~

Modifying URI properties
-------

To replace one of the URI component you can use the modifying methods exposed by all URI
object. If the modifications do not alter the current object, it is returned as is,
otherwise, a new modified object is returned.

<p class="message-notice">Any modification method can trigger a
<code>League\Uri\Contracts\UriException</code> exception if the resulting URI is not
valid. Just like with the instantiation methods, validition is scheme dependant.</p>

~~~php
<?php

public function Uri::withScheme(Stringable|string|null $scheme): self
public function Uri::withUserInfo(Stringable|string|null $user [, Stringable|string|null $password = null]): self
public function Uri::withHost(Stringable|string|null $host): self
public function Uri::withPort(?int $port): self
public function Uri::withPath(Stringable|string $path): self
public function Uri::withQuery(Stringable|string|null $query): self
public function Uri::withFragment(Stringable|string|null $fragment): self
~~~

<p class="message-info">Apart from the path component, which is always a string, to delete
a URI component you need to specify its content as being <code>null</code></p>

Since all URI objects are immutable you can chain each modifying methods to simplify URI
creation and/or modification.

~~~php
$uri = Uri::new("ws://thephpleague.com/fr/")
    ->withScheme("wss")
    ->withUserInfo("foo", "bar")
    ->withHost("www.example.com")
    ->withPort(81)
    ->withPath("/how/are/you")
    ->withQuery("foo=baz");

echo $uri; //displays wss://foo:bar@www.example.com:81/how/are/you?foo=baz
~~~

URI normalization
-------

Out of the box the package normalizes any given URI according to the non-destructive rules
of [RFC3986](https://tools.ietf.org/html/rfc3986).

These non destructives rules are:

- scheme and host components are lowercased;
- the host is converted to its ascii representation using punycode if needed
- query, path, fragment components are URI encoded if needed;
- the port number is removed from the URI string representation if the standard port is used;

~~~php
$uri = Uri::new("hTTp://www.ExAmPLE.com:80/hello/./wor ld?who=f 3#title");
echo $uri; //displays http://www.example.com/hello/./wor%20ld?who=f%203#title

$uri = Uri::fromComponent(parse_url("hTTp://www.bébé.be?#"));
echo $uri; //displays http://xn--bb-bjab.be?#
~~~

<p class="message-info">The last example depends on the presence of the <code>ext-intl</code> extension, otherwise the code will trigger a <code>IdnSupportMissing</code> exception</p>
